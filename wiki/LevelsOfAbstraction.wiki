#summary Explains the test code layout when using the JWatter framework

This page explains the code abstraction layers supported by the JWatter framework. The Java code that is generated by the JWatter toolkit observes this layout. The goal of this layout is to ensure that automated tests are easy to understand and maintain, and to avoid code redundancy.

In a JWatter web test automation project, Java code is organized in three layers that provide different levels of abstraction:

<table border="1" cellspacing="0" cellpadding="2">
<tr><th width="50%" align="center">Test cases</th><th width="50%" align="center">Actions, assertions about application state</th></tr>
<tr><td align="center">Page classes</td><td align="center">Web application logic</td></tr>
<tr><td align="center">Actor classes</td><td align="center">Actions on web page elements</td></tr>
<tr><td colspan="2" align="center" style="background-color:#cdf">JWatter API</td></tr>
</table>

The three layers are described in the following sections, beginning with the lowest level of abstraction.

= Actor classes =

Actor classes provide methods to interact with elements in a web page, such as buttons, form input fields, dropdown menus, links, images, text, in an opaque way. Each actor class corresponds to a specific page in the web application. It has separate methods for each element and for each type of interaction (e.g. check for existence, set value, get value, click). These methods are called _actor methods_.

An automated test that needs to interact with an element in a web page (e.g. fill in a username in an input field, click a link) simply calls the corresponding actor method for the element and the required type of interaction. The test does not need to know how this element is implemented in the page, for instance what its HTML tag name and attributes are. Actor classes encapsulate these implementation details and hide them from higher-level code.

Actor classes are not written manually but are generated by the JWatter web automation toolkit. The JWatter toolkit also creates a Java properties file with properties for the attributes of HTML elements. For example, the `id` attribute of the username field in a login page may be stored as
{{{
com.myapp.webtests.pages.actor.LogInActor.input9.id=username_input
}}}
These properties are called _actor properties_ and are stored in a single properties file for all actor classes. Its filename and location is specified in the `toolkit.properties` file.

For each JWatter API method that can act on a particular element, the JWatter toolkit creates a method that wraps the API method with the attribute that identifies the element. For example, for the username field, it creates the following method in the actor class:
{{{
public class LogInActor extends PageImpl {

    protected static final String input9Id = getRequiredProperty("input9.id", LogInActor.class);

    protected void setTextInputWithIdUsernameInput(String arg1) throws NoSuchElementException {
        browserFramework.setTextInputWithId(input9Id, arg1);
    }
}
}}}
The name of an actor method is generated from the wrapped API method and the attribute that identifies the element it acts on. This makes it easy for a developer who wants to access an element in particular way to choose the appropriate actor method. The base package for generated classes is specified in the `toolkit.properties` file, and actor classes are generated in the subpackage `pages.actor`, e.g. `com/myapp/webtests/pages/actor/LogInActor.java`.

Generating an actor class with the JWatter toolkit is easy:
 # Run the toolkit. The toolkit starts up a web browser and loads the web application.
 # Use the browser to navigate to the target page.
 # Enter the command for generating an actor class in the toolkit. You must provide a name for the page, which will be used to create the actor class name.

If an actor class for the given page already exists, you will be prompted whether to overwrite it. When an actor class is overwritten, all its properties will be overwritten as well. Actor classes are not meant to be edited manually. You should regenerate existing actor classes after any of the following happened:
 * A page in the web application has changed (through web application development, not normal usage).
 * The JWatter API has changed.

= Page classes =

Page classes model the web application logic. A page class provides methods that let a test interact with the web application, as opposed to interaction with elements on a web page. In other words, a page class allows a test to use the services offered by a web application, without having to worry about the details of the interaction with specific UI controls on a web page. The following example illustrates the distinction between these two levels of interaction:
 * Interacting with a web application is about _what_ you do: for instance, sign in to the application as a particular user.
 * Interacting with UI controls on a web page is _how_ you do it: fill in your email address and password in the respective fields and click the *Sign In* button.

Page classes hide the details of UI interaction. This design makes test code easier to understand (by avoiding unnecessary details) and to maintain (by avoiding duplicate code). Note the difference between actor classes and page classes:
 * Actor classes implement the details of interaction with elements in a web page.
 * Page classes represent the services offered on a page and implement these services in terms of interaction with the elements in the page.

Page classes are located in the `pages` subpackage, e.g. `com/myapp/webtests/pages/LogIn.java`. There should be one page class for each page in the web application. There is also one page class for each frame (including embedded frames) in a page.

Page classes are not generated automatically (we currently don't have intelligent algorithms in place that are able to infer the web application's services from its pages). However, the web automation toolkit creates a page class stub when an actor class is generated.

The page class name is the same as the actor class name but without the `Actor` suffix. A test developer can then populate this stub with methods for the services offered by the page (page classes are never overwritten by the toolkit). A page class extends its actor class:
{{{
public class LogIn extends LogInActor {

    public LogIn(WebAutomationFramework browserFramework) throws Exception {

        super(browserFramework);
    }

    public void logIn(String email, String password) throws Exception {

        this.setTextInputWithIdusername_input(email);
        this.setPasswordInputWithIdpassword_input(password);
        this.clickButtonWithIdloginButton();
    }
}
}}}
This makes it particularly easy to write page classes in Eclipse using Eclipse's content assistant: Just type *this* followed by a period and select one of the actor methods offered by Eclipse.

Page classes should use actor methods whenever possible and should avoid using the JWatter API methods directly. An exception from this rule is checking for the presence of specific text in a page, because the JWatter toolkit does not create actor methods for every possible piece of text. Page classes should never use any HTML properties of a page directly.

How many and which methods a page class contains depends on the complexity of the page and what functionality you want to test. The definition of a _service_ offered by a page should be rather broad: It may include checking whether some specific text is displayed (e.g. a failed login message).

Every page class has a method that allows a test to check whether the page is currently displayed in the browser:
{{{
public boolean onPage() throws Exception;
}}}
This method is specified in the `org.jwatter.model.Page` interface and is inherited from the `org.jwatter.model.PageImpl` class which is the base class of all actor classes. The JWatter toolkit stores the URL path of a page as a Java property when it creates an actor class, so every page class knows the URL of the page it represents.

= Test cases =

JWatter focuses on functional testing of web applications. Functional tests verify behavior such as:
 * login with a valid email address and password succeeds
 * login with a wrong password fails
 * navigation within the web application works correctly
 * searches return the expected results

In addition, we can also consider tests that check the appearance of pages, such as:
 * the page layout is correct
 * all images are displayed

JWatter casts automated web tests as [http://junit.org/ JUnit] tests. Automated web tests can be considered unit tests in the sense that tests are run in isolation and each test is independent of other tests, although the _unit_ that is tested is typically larger than in conventional (code) unit tests, i.e. a specific part of the web application logic rather than a method in a class.

A typical web test has the following structure:
 # *Requirement:* Require that the environment in which the test is run has been set up properly. This includes the web application being in a well-defined pre-test state. For example: a browser window is open, we are logged in and the search page is displayed.
 # *Action:* Perform one or more actions that interact with the web application and change its state in a controlled way. For example, submit a search query.
 # *Assertion:* Make assertions about the state of the web application as a result of these actions and throw an `AssertionFailed` exception if the state is not the expected state. For example, assert that the number of search results is as expected.

An assertion that is not met constitutes a test failure. In contrast, a requirement that is not met constitutes an error, because the test could not be executed.

The JWatter class `org.jwatter.test.WebFunctionalTestCase` serves as the base class for all automated web tests. It provides a test fixture that sets up the necessary environment for a test and cleans up after the test is run. In particular, it starts a web browser and points it to the specified page before a test is run, and closes the web browser afterwards.

It reads a Java properties file that specifies which web browser should be used for the test, the start URL, and other properties required by tests. Tests that require more specific set up, such as logging in to the application and navigating to a different page, and logging out after the test, can extend `WebFunctionalTestCase` to accommodate for that. The name of the properties file must be specified as a Java system property, i.e. `-Dtests.properties=tests/resources/tests.properties`.

Test cases contain member fields for all pages that are referenced by its tests (JWatter also contains base classes to model browser windows and frames that can be used in more complicated web applications to organize pages). When a test class is instantiated, these member fields are populated with page objects (instances of page classes):
{{{
public class LogInTest extends WebFunctionalTestCase {

    protected static final String userEmail    = getRequiredProperty("userEmail", LogInTest.class);
    protected static final String userPassword = getRequiredProperty("userPassword", LogInTest.class);

    protected LogIn login;
    protected Home home;

    public LogInTest() throws Exception {

        super();

        login = new LogIn(browserFramework);
        home  = new Home(browserFramework);
    }

    public void testLogIn() throws Exception {

        requiring(login.onPage());

        login.logIn(userEmail, userPassword);
        asserting(home.onPage());
    }
}
}}}
In order to avoid code duplication and to keep tests easy to maintain, tests should interact with the web application only through page objects.

Note that the lifetime of a page object is not bound to the corresponding page being rendered in the browser. A page object can be created before the page is loaded in the browser, and it can continue to exist after the browser leaves the page. The `onPage()` method on a page object can be used to determine whether the page is currently shown in the browser.

Usually there is one test class for each page containing all the tests for that page, but this is not a strict requirement. When an actor class is generated, the web automation toolkit also creates a test class stub. Test classes are generated in the `tests` subpackage (e.g. `com/myapp/webtests/tests/LogInTest.java`) but can be grouped into subpackages further as needed (e.g. `com/myapp/webtests/tests/login/LogInTest.java`).
