#summary Explains JWatter components to model web pages, windows and frames

JWatter provides three base classes (and corresponding Java interfaces) that help a test developer model the structure of her web application. The three Java interfaces are:
 * `org.jwatter.model.Page`: represents a single web page. More precisely, a `Page` instance represents a single HTML document. If a web page contains a frame (including embedded frame), the frame contents is modeled as a separate `Page` instance. The abstract class `org.jwatter.model.PageImpl` implements this interface.
 * `org.jwatter.model.Window`: represents a collection of pages that are displayed in the same browser window. The abstract class `org.jwatter.model.WindowImpl` implements this interface.
 * `org.jwatter.model.Frame`: represents a collection of pages that are displayed in the same HTML frame or embedded frame. This is an extension of `org.jwatter.model.Window`. The abstract class `org.jwatter.model.FrameImpl` implements this interface.

`org.jwatter.model.Page` is the main interface for modeling web applications. All page classes and actor classes implement this interface. A `Page` instance has a method `onPage()` that a test can use to determine whether the browser is currently displaying the page. In the default implementation (in `org.jwatter.model.PageImpl`) this is determined based on the URL. Pages that need to check other criteria can override `onPage()`. Other `Page` methods have to do with [PageLoadingAndSynchronization page loading/synchronization].

= Windows =

For small web applications with only a couple of pages and a few tests, the `Page` interface is sufficient. However, in larger applications with many pages, multiple windows and/or frames, and many test cases, it is convenient to group together related pages as member instances of a common class. This helps to avoid code redundancy when multiple tests access the same set of pages.

The `Window` interface can be used to achieve this. A window instance represents a collection of pages that are displayed in the same browser window. For the purpose of automated web testing, the main characteristics of a window are:
 * A window contains one or more pages. At any given time, one of the pages is displayed in the window.
 * A window has a unique name or id, which is given to it by the browser and which is different from all other window ids. The window id can be used to set the browser target onto the window. This is discussed below.

A window class should extend `org.jwatter.model.WindowImpl`:
{{{
public class MainWindow extends WindowImpl {

    public LogIn logIn;
    public Home home;
    public About about;
    public Search search;

    public MainWindow(WebAutomationFramework browserFramework) throws Exception {

        super(browserFramework);
    }
}
}}}
In this example, `LogIn`, `Home`, `About` and `Search` are all page classes. When an instance of (a subclass of) `WindowImpl` is created, all fields that implement the `Page` interface are automatically populated with page instances of the correct class. (One consequence is that there can only be a single instance of each page class in a window. If you need two pages of the same type, create subclasses.)

A test case can now create a window instance and access the pages in it through the public fields, instead of creating separate page instances for each page:
{{{
public abstract class LoggedInTestCase extends WebFunctionalTestCase {

    protected MainWindow mainWindow;

    protected LoggedInTestCase() throws Exception {

        super();
        mainWindow = WindowFactory.newWindow(MainWindow.class, browserFramework);
    }

    @Override
    protected void setup() throws Exception {

        super.setUp();
        try {
            // set the name of the main window to the id generated by the browser
            mainWindow.setName();
            signIn();
            ...
        }
        ...
    }
}

public class AboutTest extends LoggedInTestCase {

    @Override
    protected final void setUpLoggedInTestCase() throws Exception {

        mainWindow.home.openAbout();
    }
}
}}}
In the following, we discuss some applications of windows.

= Shortcuts for common page functionality =

A window class can be used to implement shortcuts for page functionality that all pages have in common. Imagine, for example, that all pages in your web application's main window contain a sign-out link. Each page should implement a method `signOut()`. In addition, the main window class can implement a `signOut()` method that determines the current page (the page that is currently shown in the main window by the browser) and delegate the method call to the page's `signOut()` method. The test fixture can then simply call `signOut()` on the window instance instead of having to determine the current page first.

To do this, we first define an interface that describes common functionality and that all pages that provide this functionality can implement:
{{{
public interface Navigation {

    // log out
    public void signOut() throws Exception;

    // go to the Home page
    public void home() throws Exception;

    // go to the About page
    public void openAbout() throws Exception;
}
}}}
In MainWindow, we use the `getCurrentPage()` method (defined in `Window` and implemented in `WindowImpl`) to get the page that is displayed in the browser window and delegate the `signOut()` method call:
{{{
public class MainWindow extends WindowImpl {

    public void signOut() throws Exception {

        ((Navigation)this.getCurrentPage()).signOut();
    }

    public void home() throws Exception {

        ((Navigation)this.getCurrentPage()).home();
    }

    public void openAbout() throws Exception {

        ((Navigation)this.getCurrentPage()).openAbout();
    }
}
}}}
We can then write tests like the following:
{{{
public class HomeTest extends LoggedInTestCase {

    public void testNavigation() throws Exception {

        mainWindow.openAbout();
        asserting(mainWindow.about.onPage());
        mainWindow.home();
        asserting(mainWindow.home.onPage());
    }
}
}}}
This example shows one of the main benefits of window classes: The separation of application logic and test logic. Without a window class, we would have to create shortcuts like `home()` and `signOut()` in the test case class.

= Different pages for different users =

A web application may allow different users to see different pages, depending on user privileges. For example, imagine two users, _standarduser_ and _admin_. The latter has administration privileges. _Admin_ can see all pages that _standarduser_ can see, and in addition can see pages with functionality for administration tasks that _standarduser_ cannot see.

We can make our test cases user-independent by creating a second window class for the _admin_ user and passing in user-specific properties, such as log-in credentials and the main window class, to the test case constructor:
{{{
public class MainWindowForAdmin extends MainWindow {

    public AdminPage adminPage;

    public MainWindowForAdmin(WebAutomationFramework browserFramework) throws Exception {

        super(browserFramework);
    }
}
}}}
To bundle all user properties, we create a `User` class:
{{{
public class User {

    protected String loginName;
    protected String password;
    protected Class<?extends MainWindow> mainWindowClass;

    public User(String loginName, String password, Class<?extends MainWindow> mainWindowClass) {

        this.loginName = loginName;
        this.password = password;
        this.mainWindowClass = mainWindowClass;
    }

    public String getLoginName() {
        return loginName;
    }

    public String getPassword() {
        return password;
    }

    public Class<?extends MainWindow> getMainWindowClass() {
        return mainWindowClass;
    }
}
}}}
We can now change the test case base class to pass in a user instance to the constructor:
{{{
public abstract class LoggedInTestCase extends WebFunctionalTestCase {

    protected User testUser;
    protected MainWindow mainWindow;

    protected LoggedInTestCase(User testUser) throws Exception {

        super();
        this.testUser = testUser;
        mainWindow = WindowFactory.newWindow(testUser.getMainWindowClass(), browserFramework);
    }

    @Override
    protected void setUp() throws Exception {

        super.setUp();
        try {
            mainWindow.setName();
            signIn(testUser.getLoginName(), testUser.getPassword());
            ...
        }
        ...
    }
}
}}}

= Frames =

A frame is similar to a window, except that a frame is not an independent entity, rather, a frame must have a parent window (which may be another frame). Like a window, a frame has a name. Unlike a window, the name is not generated by the browser, but instead is defined in the _frame_ or _iframe_ tag in the HTML source of the page that the frame is contained in.

The JWatter toolkit commands *list* and *inspect* are useful to find the names of frames in a page:
 # Start the JWatter toolkit and navigate to the page you are interested in.
 # Type *list frame* or *list iframe* to see the frame tags and their attributes. The name of a frame is the value of the _id_ or _name_ attribute.
 # Type *target frame NAME* to set the target to a frame. Then type *inspect body* to verify that you are looking at the right frame.
 # Type *target default* to set the target back to the window.

= Switching windows and frames =

Webdriver always operates on a _target_ window or frame. The default target is the first browser window after the web browser has been started. If your test needs to access a page that is in a different window, or in a frame, you must switch the target to that window or frame.

The `Window` and `Frame` interfaces provide methods that make switching windows and frames convenient:
 * `window.setAsTarget()` sets the browser target to the specified window.
 * `frame.setAsTarget()` sets the window containing the specified frame as the active window and sets the browser target to the frame.

Before you can call `setAsTarget()`, you must set the window name by calling `window.setName()`, after the browser opened the window that this window instance represents. This sets the window name to the unique window id generated by the browser. To set the name of a frame, call `frame.setName(name)`, where _name_ is the value of the _id_ or _name_ attribute in the _frame_ or _iframe_ tag. Since this name is not generated by the browser, it can be set even before the frame exists in the browser.

You must always set the target explicitly if your test requires a different target. If your test clicks a link or button that opens a new window, the target will still be the same window or frame. If you close a window that is the current target, you must switch the target back to the previous window, otherwise any subsequent calls to the JWatter API will throw exceptions. The same is true for frames.

The `org.jwatter.browser.WebAutomationFramework` interface provides methods to specify window and frame names explicitly:
 * `setTargetToWindow(windowname)` switches to the specified window.
 * `setTargetToWindow(null)` switches to the default window (the first open browser window).
 * `setTargetToFrame(frameid)` and `setTargetToFrame(framename)` switch to the specified frame within the current window.

Finding the name of a window can be difficult, because window names are not defined in HTML attributes. Javascript opens a new window by calling `window.open(url,windowname,options)`. The window name is the second argument of that method. You may need to trace the Javascript from the link that opens the window to the `window.open()` call. Note that the browser always assigns a unique id to each window it opens, which is independent from the Javascript window name.
